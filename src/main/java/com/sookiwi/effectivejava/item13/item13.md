# 클론을 오버라이드 할때는 현명하게 하라(WIP)

Clonable 인터페이스는 mixin interface로 의도되어 설계되어, 클론 가능하다는 것을 명시적으로 드러내기 위함이었다. 그러나 실제로는 그 목적을 달성하지 못한다. clone method가 없고, Object의 clone은 보호되어 있기 때문이다. Cloneable을 구현했다는 이유로 reflection을 활용하지 않는 이상 clone을 부를 수 없다. reflection조차도 실패할 수 있는데, 왜냐하면 오브젝트가 접근 간ㄱ으한 clone 메소드를 가지고 있다는 것을 보장할 수 없기 때문이다. 이런저런 결함들에도 불구하고, 이 기능은 합리적으로 많이 이용되고 있기에 이해해볼만한 가치가 있다. 어떻게 하면 well-behaved clone 메소드를 만들 수 있는지, 언제 만드는게 적합한지, 대안은 무엇인지 살펴보자.

Cloneable은 무엇을 위함인가? Object의 보호된 clone 구현을 결정한다. Cloneable을 구현하고 있으면, Object의 clone은 필드-필드 복사를 리턴한다. 그렇지 않으면 그것은 `CloneNotSupportedException`을 던진다. 이것은 상당히 특이한 유형의 인터페이스 사용이다. 일반적으로, 인터페이스를 구현하는 것은 그 클래스가 그 클라이언트를 위해 무엇을 해줄 수 있는 지를 말하기 위함이다. 이 경우에는, 이것은 슈퍼클래스의 보호된 동작을 수정한다.

명세에 적혀있진 않지만, **실제로는, Cloneable을 구현한 클래서는 제대로 동작하는 public clone 메소드를 제공하는 것이 기대된다.** 이를 달성하기 위해, 그 클래스와 모든 그 슈퍼클래스들은 복잡하고, 강제할 수 없고, 거의 문서화되지 않은 프로토콜에 따라야한다. 그 결과는 깨지기 쉽고, 위험하고, *언어외적(extralinguistic)*이다: 생성자 없이 객체를 만들어낸다.
